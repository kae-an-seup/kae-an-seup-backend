<!DOCTYPE html>
<html>
  <head>
    <title>얼굴 랜드마크 감지</title>
    <!-- TensorFlow.js 및 관련 라이브러리 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.1/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.1/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.1/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.1/face_mesh.js" crossorigin="anonymous"></script>
  </head>
  <body>
    <!-- <h1>얼굴 랜드마크 감지 예제</h1> -->
    <!-- <video id="webcam" autoplay></video>
    <canvas id="output"></canvas> -->

    <div class="container" style="margin-top: 20px;">

        <div class="columns">
          
          <!-- WEBCAM INPUT -->
          <div class="column" style="display: none;">
            <article class="panel is-info">
              <p class="panel-heading">
                Webcam Input
              </p>
              <div class="panel-block">
                <video class="input_video2"></video>
              </div>
            </article>
          </div>
    
          <!-- MEDIAPIPE OUTPUT -->
          <div class="column">
            <article class="panel is-info">
              <p class="panel-heading">
                Mediapipe Face Mesh
              </p>
              <div class="panel-block">
                <canvas class="output2" width="480px" height="480px"></canvas>
              </div>
            </article>
          </div>
        </div>
        
        <div class="loading">
          <div class="spinner"></div>
        </div>
      <div style="visibility: hidden;" class="control2">
      </div>


    <script>
        class FPS {
        constructor() {
            this.startTime = 0;
            this.frameCount = 0;
        }

        tick() {
            const currentTime = performance.now();
            if (!this.startTime) {
            this.startTime = currentTime;
            }

            if (currentTime - this.startTime >= 1000) {
            const fps = this.frameCount;
            console.log(`FPS: ${fps}`);
            this.startTime = currentTime;
            this.frameCount = 0;
            }

            this.frameCount++;
        }
        }



        const video2 = document.getElementsByClassName('input_video2')[0];
        const out2 = document.getElementsByClassName('output2')[0];
        const controlsElement2 = document.getElementsByClassName('control2')[0];
        const canvasCtx = out2.getContext('2d');

        const fpsControl = new FPS();
        const spinner = document.querySelector('.loading');
        spinner.ontransitionend = () => {
        spinner.style.display = 'none';
        };

        function onResultsFaceMesh(results) {
        document.body.classList.add('loaded');
        fpsControl.tick();

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, out2.width, out2.height);
        canvasCtx.drawImage(
            results.image, 0, 0, out2.width, out2.height);
        if (results.multiFaceLandmarks) {
            for (const landmarks of results.multiFaceLandmarks) {
            drawConnectors(
                canvasCtx, landmarks, FACEMESH_TESSELATION,
                {color: '#C0C0C070', lineWidth: 1});
            drawConnectors(
                canvasCtx, landmarks, FACEMESH_RIGHT_EYE,
                {color: '#FF3030'});
            drawConnectors(
                canvasCtx, landmarks, FACEMESH_RIGHT_EYEBROW,
                {color: '#FF3030'});
            drawConnectors(
                canvasCtx, landmarks, FACEMESH_LEFT_EYE,
                {color: '#30FF30'});
            drawConnectors(
                canvasCtx, landmarks, FACEMESH_LEFT_EYEBROW,
                {color: '#30FF30'});
            drawConnectors(
                canvasCtx, landmarks, FACEMESH_FACE_OVAL,
                {color: '#E0E0E0'});
            drawConnectors(
                canvasCtx, landmarks, FACEMESH_LIPS,
                {color: '#E0E0E0'});
            }
        }
        canvasCtx.restore();
        }

        const faceMesh = new FaceMesh({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.1/${file}`;
        }});
        faceMesh.onResults(onResultsFaceMesh);

        const camera = new Camera(video2, {
        onFrame: async () => {
            await faceMesh.send({image: video2});
        },
        width: 480,
        height: 480
        });
        camera.start();

        new ControlPanel(controlsElement2, {
            selfieMode: true,
            maxNumFaces: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
            })
            .add([
            new StaticText({title: 'MediaPipe Face Mesh'}),
            fpsControl,
            new Toggle({title: 'Selfie Mode', field: 'selfieMode'}),
            new Slider({
                title: 'Max Number of Faces',
                field: 'maxNumFaces',
                range: [1, 4],
                step: 1
            }),
            new Slider({
                title: 'Min Detection Confidence',
                field: 'minDetectionConfidence',
                range: [0, 1],
                step: 0.01
            }),
            new Slider({
                title: 'Min Tracking Confidence',
                field: 'minTrackingConfidence',
                range: [0, 1],
                step: 0.01
            }),
            ])
            .on(options => {
            video2.classList.toggle('selfie', options.selfieMode);
            faceMesh.setOptions(options);
            });
    </script>

  </body>
</html>
